#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<assert.h>
//debug 调试版本 可以f10，调试，文件大，包含了调试信息。

//release 发布版本，软件大小更小，不可以调试，比debug 更优化。
//在功能上更优化。


//F5启动调试 和 F9配合使用。

//F9设置/取消断点。停在断点处。F5直接执行到断点处。

//F5，跳到执行逻辑上的下一个断点。

//F10,关注过程。

//F11，逐语句。不会放过函数细节。

//shift  f11 跳出函数（执行完）；

//shift f5 停止调试

//窗口――自动窗口，当程序再执行过程中，会自动把程序执行到这个位置上下文的局部变量添加。

//调栈，可以查看函数调用的逻辑顺序

//右键断点，条件断点。，监视。


//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%p\n", &i);
//	printf("%p\n", arr);
//
//	//VC6.0 <=10		死循环
//	//gcc 编译器<=11	死循环
//	//vs 2019 <=12		死循环
//	for ( i = 0; i <=12; i++)
//	{
//		printf("hehe\n");
//		arr[i] = 0;
//	}
//	//局部变量会用到栈区，栈区默认先使用高地址，后使用低地址。
//	//数组地址由低到高变化。
//	//在越界的过程中，会非法访问到i的地址，改变了i的值，从而导致死循环。
//
//	return 0;
//}

						//自己的复制函数。

//返回目的地的地址。

// 将源内容复制到目的地，const 意味源头的数据不能被修改。
//char* my_strcpy(char* dest, const char* src)
//{
//	//const 放在*的左边，不能通过地址修改指针指向对象的值，
//	//放在右边，不能改变指针变量本身。
//
//	/*while (*src != '\0')
//	{
//		*dest = *src;
//		*src++;
//		*dest++;
//	}
//	*dest = *src;*/
//	/*while (*src != '\0')
//	{
//		*dest++= *src++;
//	}*/
//	//if (*dest != NULL && *src != NULL)
//	//{
//	//	while (*dest++ = *src++)//先赋值使用，后++
//	//	{
//	//		;
//	//	}
//	//}
//
//	//把src指向的字符串内容拷贝到dest指向的空间，包含‘\0’字符。
//	char* ret = dest;
//	assert(dest!=NULL);//断言
//	assert(src != NULL);// 会报错问题出现在哪里。
//
//	while (*dest++ = *src++)//先赋值使用，后++
//	{
//		;
//	}
//	return ret;
//}
//
//
//int main()
//{
//	char arr1[] = "$$$$$$$$$$$$$$$$$$";
//	char arr2[] = "bit";
//	printf("%s\n", my_strcpy(arr1, arr2));
//	return 0;
//}

						//自建 求字符串长度。	
/*
* const 修饰 不能改变字符串的内容。
	assert 断言 不能等于空指针，
	计数++；地址++；

	双击错误，找到语法错误地址。
	链接型错误，标识符符号未定义，或没有。

*/